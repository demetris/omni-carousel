
Omni Carousel library map
================================================================================

Concept inspired by Aider: <https://aider.chat/docs/repomap.html>

-   2025-07-20. Added description of 3-phase init
-   2025-07-19. Updated by CC and Demetris, new section added (DOM querying)
-   2025-07-09. Updated by Claude Code
-   2025-07-01. Generated by Claude Code


Architecture overview
----------------------------------------

The omni-carousel library follows a **modular, event-driven architecture** with clear separation of concerns:

-   **Core**: Configuration, types, and main carousel creation
-   **DOM**: DOM manipulation and element interactions  
-   **Features**: Individual carousel features (buttons, indicators, scrolling)
-   **Handlers**: Event handlers for native and custom events
-   **Navigation**: Scrolling and navigation logic
-   **State**: State management and updates
-   **Utils**: Utility functions and browser feature detection


Core module (`/lib/core/`)
----------------------------------------

### carousel.ts

Main entry point for creating carousel instances

-   `createOmniCarousel(root, options?)` - Factory function returning public API
-   Manages lifecycle: init, setup, destroy
-   Sets up observers: ResizeObserver, IntersectionObserver
-   Central orchestrator for all other modules

### types.ts

TypeScript type definitions for the entire library

-   `OmniAPI` - Public API interface
-   `Options` - User configuration options
-   `Config` - Full configuration after merging
-   `State` - Dynamic carousel state
-   `Context` - Combined context object
-   `OmniEvents` - Custom event types

### config.ts

Configuration merging and validation

-   `mergeConfig(options?)` - Merges user options with defaults

### defaults.ts

Default configuration values

-   `defaults` - Default options object

### internal-config.ts

Internal constants and configuration

-   `internalConfig` - CSS classes, selectors, data attributes


DOM module (`/lib/dom/`)
----------------------------------------

### elements.ts

DOM element selection and validation

-   `getElements(root, selectors)` - Queries carousel elements

### attributes.ts

DOM attribute management

-   `captureInitialAttributes()` - Stores initial states
-   `resetElementAttributes()` - Restores original attributes
-   `setElementAttributes()` - Sets carousel attributes
-   `ensureTrackPositioned()` - Ensures proper CSS positioning

### styles.ts

CSS class and style management

-   `clearItemAttributes()` - Removes carousel attributes
-   `getScrollSnapAlign()` - Gets scroll-snap-align value
-   `updateCenterItem()` - Updates centered item
-   `updateCenterGroupItem()` - Updates centered group
-   `updateItem()` - General item updates


Features module (`/lib/features/`)
----------------------------------------

### buttons.ts

Navigation button state management

-   `updateButtons()` - Updates all button states
-   `updateBackwardButtons()` - Updates prev/start buttons
-   `updateForwardButtons()` - Updates next/end buttons

### indicators.ts

Indicator button creation and management

-   `addIndicators()` - Creates indicator buttons
-   `centerIndicators()` - Centers overflowing indicators
-   `clearIndicators()` - Removes indicators
-   `updateIndicator()` - Updates individual indicator
-   `updateIndicatorOverflow()` - Manages overflow state

### scroll.ts

Custom scrolling logic

-   `scrollToCenter()` - Centers elements or groups of elements

### invisible-anchor.ts

Invisible-element hack for centering multiple elements as a group

-   `createInvisibleAnchor()` - Creates invisible element to overlay on group
-   `placeInvisibleAnchor()` - Positions element over group to center
-   Enables `scrollIntoView()` to center multiple elements as one unit
-   Chrome/Blink requires new element per scroll (`forceNew=true`)
-   Firefox/Safari can reuse the same invisible element

### Navigation helpers

-   **steps-one.ts** - Single-step navigation
-   **steps-all-align-start.ts** - Start-aligned navigation
-   **steps-all-align-center.ts** - Center-aligned navigation
-   **steps-auto-align-all.ts** - Auto-step navigation (renamed from steps-many-align-all.ts)

### utils.ts

Feature-specific utilities

-   `calculateCenterScrollPosition()` - Center scroll calculation
-   `getFallbackItem()` - Fallback navigation item
-   `getRectCenterX()` - Element center coordinate
-   `getInboundItems()` - Calculates items that fit when scrolling (auto-step mode)


Handlers module (`/lib/handlers/`)
----------------------------------------

### Native DOM event handlers

-   **event-click.ts** - Button and indicator clicks
-   **event-keyboard.ts** - Keyboard navigation (left/right/home/end)
-   **event-scrollend.ts** - Scroll completion
-   **event-transitionend.ts** - CSS transition completion

### Custom Omni event (nanoevents) handlers

-   **omni-event-init.ts** - Carousel initialization
-   **omni-event-setup.ts** - Setup when overflow detected
-   **omni-event-destroy.ts** - Cleanup handling
-   **omni-event-dimensions-change.ts** - Resize handling
-   **omni-event-visibility-change.ts** - Item visibility changes

### Observer handlers

-   **observation-intersection.ts** - IntersectionObserver entries
-   **observation-resize.ts** - ResizeObserver entries


Navigation module (`/lib/navigation/`)
----------------------------------------

### index.ts

Central navigation logic

-   `navigate()` - Main navigation function
-   Determines navigation mode from config
-   Handles 5 different navigation modes
-   Coordinates with features for scrolling


State module (`/lib/state/`)
----------------------------------------

### set.ts

State creation and initialization

-   `createState()` - Creates initial state
-   `populateMaps()` - Creates slide index mappings

### update.ts

State update logic

-   `updateIntersectionState()` - Updates visibility state


Utils module (`/lib/utils/`)
----------------------------------------

### arrays.ts

Array manipulation

-   `insertInOrder()` - Ordered insertion
-   `removeAtIndex()` - Element removal

### browser-support.ts

Feature detection

-   `hasBlinkEngine()` - Chrome/Blink detection
-   `supportsRequirements()` - Returns browser compatibility results with specific missing features
-   `supportsScrollend()` - Event support check

### debounce.ts

-   `debounce()` - Function debouncing

### measurements.ts

Item spacing calculation

-   `getItemSpacing()` - Calculates spacing between slides, caches result in state


Key architectural patterns
----------------------------------------

### Event flow

DOM events → Handlers → Custom events → State updates → UI updates

### Data flow

Context object (config + state + elements + utils) passed through all functions

### Module dependencies

-   Core orchestrates all modules
-   Handlers coordinate features and DOM
-   Navigation uses features for scrolling
-   Utils provides cross-cutting functionality

### Lifecycle

init() → setup() → active carousel → destroy()

Three-phase initialization with continuous monitoring:

1.  createOmniCarousel() - Creates instance, validates elements
2.  init() - Sets up lazy visibility detection (waits for carousel to be visible)
3.  setup() - Runs when overflow detected (adds features)

A ResizeObserver runs continuously after visibility, enabling:

-   Automatic partial destroy on overflow → no overflow
-   Automatic setup on no overflow → overflow

### Performance optimizations

-   State-based caching for expensive calculations
-   Observers for efficient change detection
-   Passive event listeners


Key architectural patterns: Performance: DOM querying
----------------------------------------

The codebase uses a number of techniques that
make it possible to navigate while querying the DOM as little as possible.

1.  Index maps & direct array access
    -   slideIndexMap: Maps DOM elements to their indexes, avoiding indexOf() calls
    -   Direct array access via `slides[index]` instead of nextSibling/previousSibling
    -   Indicators array with direct index access

2.  Mathematical index calculations
    -   Adjacent item: anchorIndex ± 1 (clamped to bounds)
    -   Start button: Always index 0
    -   End button: Always slides.length - 1
    -   No DOM traversal for finding next/previous items

3.  Aggressive caching in state
    -   itemWidth: Cached for carousels with equal widths
    -   itemWidthMap: Per-item width cache (`Map<index, width>`)
    -   itemSpacing: Cached gap between slides
    -   indicatorWidth & indicatorSpacing: Cached indicator measurements
    -   containerLeft: Lazily cached container position
    -   centeredItemIndex & previousCenteredItemIndex: Navigation history

4.  Array maintenance without DOM queries
    -   fullItems & partItems: Arrays maintained via IntersectionObserver
    -   insertInOrder(): Uses indexes to maintain DOM order without querying siblings
    -   Arrays sorted by original index, not DOM position

5.  Smart navigation strategies
    -   Fast path: When one item visible or cached center index valid, use pure math
    -   Slow path: Only when necessary, calculate positions
    -   Pre-calculated inbound items for multi-step navigation

6.  Boundary detection without DOM
    -   Start boundary: index === 0
    -   End boundary: index === slides.length - 1
    -   No need to check for first/last child

7.  Utility functions that cache
    -   getItemIndex(): Returns cached index from slideIndexMap
    -   getItemWidth(): Returns cached width or calculates once
    -   getContainerLeft(): Calculates once, returns cached value

8.  Event-driven state updates
    -   IntersectionObserver updates arrays based on visibility
    -   ResizeObserver clears caches when dimensions change
    -   No polling or repeated DOM queries

9.  One-time setup
    -   populateMaps(): Creates slideIndexMap once during init
    -   Element references stored once in elements object
    -   No repeated querySelector calls

10. Optimized multi-step navigation
    -   getInboundItems(): Calculates how many items fit without measuring each
    -   Uses cached width when hasEqualWidths is true
    -   Accumulates widths mathematically

Key insight: Omni treats the DOM as a data source to query once during setup,
then works entirely with indexes and cached values during navigation. It's
essentially a virtual representation of the carousel state that avoids
touching the DOM unless absolutely necessary.


Public API
----------------------------------------

```typescript
const carousel = createOmniCarousel(element, options);

//
// Navigation
//
carousel.next();
carousel.prev();
carousel.goTo(index);

//
// Lifecycle
//
carousel.init();
carousel.setup();
carousel.destroy();

//
// Events
//
carousel.on('omni:visibility:change', callback);
carousel.on('omni:nav:next', callback);
// ... and more
```
